# Chores-4

## 20260211 - Fix compare: optional `-p` and glob `-t` handling

### Context

The `compare` command has two issues:

1. **`-p` is required but should be optional.** Build, Run, and Test all default to the current directory package when `-p` is omitted. Compare requires it, which is inconsistent and unnecessary for POPs.

2. **`-t` with shell-expanded globs fails.** The `-t` flag uses clap's `Append` action, which captures only one value per `-t` flag. When the shell expands an unquoted glob like `tspec compare -t *.ts.toml` into `tspec compare -t file1.ts.toml file2.ts.toml`, clap rejects the second file as an unexpected argument.

### Plan

**Step 1: `src/cmd/compare.rs` — Make `-p` optional, fix `-t`**

- Change `package: String` to `Option<String>` with `current_package_name()` fallback
- Change `-t` from `action = Append` to `num_args = 1..` so shell-expanded globs work
- Use `resolve_package_dir()` + `get_package_name()` in `execute()`

**Step 2: Add tests**

- CLI parse tests for `CompareCmd`: optional `-p`, `-t` with multiple values, no `-t` defaults
- `find_tspecs` test for multi-dot filenames (`tspec.musl.ts.toml` matching `tspec*.ts.toml`)

### Result

Done. `-p` is now optional (defaults to cwd package), `-t` accepts shell-expanded globs via `num_args = 1..`. Removed broken spec files (dyn-opt, static-opt). 8 new tests added.

### References

- todo.md items: "-p shouldn't be needed for `ts compare` if in a POP" and "for build, run ... a -t should support glob like in compare"

## 20260212 - Always include cargo --release baseline in compare

### Context

`tspec compare` only compares builds using tspec files. If no tspec files exist, it errors out. We want a plain `cargo build --release` result always included as a baseline reference point — even with zero tspec files.

### Problems

- `build_package(pkg_name, None, release)` auto-discovers default `tspec.ts.toml` if it exists — no way to force a plain build
- `find_tspecs()` errors when no tspec files match — compare can't run without specs
- `compare_specs()` only iterates spec paths, no baseline concept

### Plan

1. Add `build_package_plain()` in `cargo_build.rs` — always does plain cargo build, skips spec lookup
2. Add `build_baseline()` helper in `compare.rs`, modify `compare_specs()` to build cargo --release first
3. Allow empty tspec list in `cmd/compare.rs` — default pattern returns empty vec instead of erroring

### Result

Done. `compare` now always builds a `cargo --release` baseline first, then any tspec builds. Three changes:
- `build_package_plain()` in `cargo_build.rs` — plain cargo build that skips tspec lookup
- `build_baseline()` + modified `compare_specs()` in `compare.rs` — baseline always first in results
- `cmd/compare.rs` — default tspec pattern gracefully returns empty vec (explicit `-t` still errors if no match)

## 20260212 - Detect and remove stale tspec-generated build.rs

### Problem

When a spec with `linker.args` (e.g., musl with `-static -nostdlib`) is built, tspec generates a temporary `build.rs` with `cargo:rustc-link-arg-bin=` directives. If the build is interrupted (Ctrl+C), this `build.rs` is left behind. All subsequent builds — including plain `cargo build --release` — silently pick it up, applying the linker args to every build. With `-static -nostdlib` on glibc, this produces a tiny binary that segfaults immediately (missing C runtime startup code).

### Fix

- Added `is_tspec_generated_build_rs()` — detects tspec-generated files by marker comment (`// Generated by tspec`) or by content (file only contains `cargo:rustc-link-arg-bin=` println lines)
- Added `remove_stale_tspec_build_rs()` — removes stale files before building
- Called from both `build_package()` and `plain_cargo_build_release()`
- Warning printed after build completes (so it's visible after cargo output scrolls by)
- 8 new tests for detection and removal logic
- Added todo item for the larger design question: what to do when a package has a real `build.rs` and the spec has `linker.args`

## 20260212 - Design: tspec-build library for linker.args

### Problem

When a package has its own `build.rs` and a spec has `linker.args`, tspec silently drops the linker args (no warning, no error). The current approach of generating a temporary `build.rs` is fundamentally incompatible with user-owned build scripts.

### Options considered

1. **Error out** — refuse to build, safest but unhelpful
2. **Warn and skip** — build without linker.args, visible but still broken
3. **Merge into existing build.rs** — fragile, modifies user code
4. **Move to RUSTFLAGS** (`-C link-arg=`) — affects all crates including host/proc-macros
5. **Temporarily rename user's build.rs** — interrupt-vulnerable, loses user functionality during build
6. **`tspec-build` library crate** — user calls `tspec_build::emit_linker_flags()` from their build.rs

### Proposed: option 6 — `tspec-build` crate

A small library crate that reads linker.args from the spec and emits `cargo:rustc-link-arg-bin=` directives. User adds it to `[build-dependencies]` and calls it from their build.rs:

```rust
fn main() {
    // user's existing logic
    tspec_build::emit_linker_flags();
}
```

**Benefits:** no file conflicts, interrupt-safe, explicit opt-in, composable with any build.rs logic.

**Open questions:**
- How does the library find the right spec file at build time?
- Should tspec set an env var (e.g., `TSPEC_FILE`) before invoking cargo?
- For packages without build.rs, keep auto-generating or always require the library?

### Decision

Option 6 with a thin implementation:
- `tspec-build` is a standalone crate (no dependency on tspec)
- Only depends on `toml` and `serde` to read the spec file
- Reads `TSPEC_SPEC_FILE` env var (set by tspec before invoking cargo)
- Extracts `linker.args` from the spec
- Emits `cargo:rustc-link-arg-bin=` for each arg using `CARGO_PKG_NAME`
- tspec sets the env var in `apply_spec_to_command()`

### Plan

1. Create `tspec-build/` crate with minimal dependencies
2. Have tspec set `TSPEC_SPEC_FILE` env var when building with a spec
3. Test independently first, then integrate as tspec's own build.rs later

### Status

Implementation in progress

## 20260214 - Add compare --workspace for all-packages mode

### Context

`tspec compare` requires a specific package and errors at workspace root. Build and test
already support `-w`/`--workspace` for all-packages mode. Add the same pattern to compare.

### Plan

1. Add `-w`/`--workspace` and `--fail-fast` flags to CompareCmd
2. Add `compare_all()` and `print_compare_summary()` to `all.rs`
3. Disallow `-t` in all-packages mode (each package uses its own tspecs)

### Result

Done. Compare now supports `-w`/`--workspace` and `--fail-fast`, matching build and test.
In all-packages mode, per-package comparison tables are deferred to the end summary.
With a single package, only the per-package table is shown (no redundant overall summary).
`compare_specs` returns results for callers to print via `print_comparison`.

## 20260215 - Design: Profile support and tspec section scoping

### Context

tspec currently has three sections (`[cargo]`, `[rustc]`, `[linker]`) but their scope and
interaction with cargo profiles isn't well-defined. The todo item "Support profile
definition/modification in tspecs" prompted a design discussion.

### Goal

Long-term: tspec should apply compilation settings at the narrowest possible granularity.
Today that's per-package (one tspec per Cargo.toml). Future direction: per-dependency tspecs,
where a dependency carries its own tspec that the top-level build can honor.

### Key findings

**Current tspec sections (5 total)**

A tspec has 5 sections today:
1. Unnamed "global" — top-level fields: `panic` (PanicMode), `strip` (StripMode)
2. `[cargo]` — profile, target_triple, target_json, unstable, target_dir
3. `[rustc]` — opt_level, panic (PanicStrategy), lto, codegen_units, build_std, flags
4. `[linker]` — args
5. `[linker.version_script]` — global, local

**Panic overlap: global vs `[rustc]`**

`panic` exists at two levels with no conflict detection:
- Global `panic` (PanicMode): high-level intent (unwind/abort/immediate-abort), expands to
  both cargo `-Z` flags and rustc `-C panic=` flags
- `rustc.panic` (PanicStrategy): low-level rustc `-C panic=` directly

If both are set, duplicate `-C panic=` flags are emitted into RUSTFLAGS. This overlap
should be resolved — likely by keeping only the global high-level version (which handles
the immediate-abort case that needs both cargo and rustc flags).

**Cargo profile mechanism: `cargo --config`**

Cargo supports inline TOML config overrides via `--config`:
```bash
cargo build --config 'profile.release.opt-level=3' --config 'profile.release.lto=true'
```
This is a cargo CLI flag (not rustc). It overrides `[profile.*]` settings from Cargo.toml.

Note: `rustc --cfg` is completely different (conditional compilation flags for `#[cfg(...)]`).

**RUSTFLAGS vs `cargo --config` — same blast radius today**

Both RUSTFLAGS and `cargo --config` profile settings apply to the target package AND all
its dependencies within a single `cargo build -p <pkg>` invocation. Since tspec runs a
separate cargo invocation per package, neither leaks across packages.

The real reasons to prefer `cargo --config` are:
1. **Per-package targeting** — `--config 'profile.release.package.serde.opt-level=2'`
   lets you set different options per dependency. RUSTFLAGS has no equivalent. This is
   the only path to dependency tspecs.
2. **Settings with no `-C` flag** — `debug`, `overflow-checks`, `incremental`,
   `split-debuginfo` can only be set via profiles, not RUSTFLAGS.
3. **Fingerprinting** — cargo understands `--config` profile changes and recompiles
   correctly. RUSTFLAGS changes also trigger recompiles but cargo treats it as a blunt
   "rebuild everything" signal.

**Current section scopes**

| Section                | Intended scope | Actual scope        | Mechanism                              |
|------------------------|----------------|---------------------|----------------------------------------|
| Global (panic, strip)  | Package        | Package + all deps  | Expands to cargo -Z + RUSTFLAGS        |
| `[cargo]`              | Package        | Package             | `--release`, `--target`, `-Z` flags    |
| `[rustc]`              | Package        | Package + all deps  | `RUSTFLAGS` env var                    |
| `[linker]`             | Per-binary     | Per-binary          | Generated `build.rs` with link-arg-bin |
| `[linker.version_script]` | Per-binary  | Per-binary          | Generated version script + link-arg    |

**Overlap between `[rustc]` and cargo profiles**

Several `[rustc]` fields duplicate what cargo profiles already express:
- `rustc.opt_level` -> `-C opt-level=N` (same as `profile.*.opt-level`)
- `rustc.lto` -> `-C lto=true` (same as `profile.*.lto`)
- `rustc.codegen_units` -> `-C codegen-units=N` (same as `profile.*.codegen-units`)
- `rustc.panic` -> `-C panic=abort` (same as `profile.*.panic`)
- High-level `strip` -> `-C strip=symbols` (same as `profile.*.strip`)

These should move to `[cargo.profile.*]` because:
1. `cargo --config` is the only path to per-dependency profile control
2. Some settings only exist as profile options with no RUSTFLAGS equivalent
   (`debug`, `overflow-checks`, `incremental`, `split-debuginfo`)
3. Cargo profiles support per-package overrides: `[profile.release.package.dep-name]`
   (subset: `opt-level`, `codegen-units`, `overflow-checks`, `debug`, `debug-assertions`,
   `strip`, `lto`)
4. Not yet released, so removal > deprecation

**Proposed section scoping**

| Section               | Role                                              | Mechanism            |
|-----------------------|---------------------------------------------------|----------------------|
| `[cargo]`             | Build settings: target, unstable flags, target_dir | Cargo CLI args       |
| `[cargo.profile.*]`   | New: profile settings cargo can scope per-package  | `cargo --config`     |
| `[rustc]`             | Shrinks to raw flags with no profile equivalent    | `RUSTFLAGS` / `-C`   |
| `[linker]`            | Per-binary link args, version scripts              | Generated `build.rs` |

**Compiler-level attributes (beyond profiles)**

Rust offers limited function-level control:
- Stable: `#[inline]`, `#[inline(always)]`, `#[cold]`, `#[target_feature(enable = "avx2")]`
- Nightly: `#[optimize(size)]` / `#[optimize(speed)]` (closest to per-block opt-level)
- Nothing at per-file or per-block level for full profile control

**Dependency tspecs are viable**

Key discovery: `cargo package` preserves `*.ts.toml` files in published crates.
Verified with `cargo package --list -p tspec --allow-dirty` — tspec files appear in
the package list and would travel through crates.io.

This means dependency tspecs work for all scenarios:
- Workspace members (local)
- Path/git dependencies (local)
- crates.io dependencies (tspec files preserved in registry at `~/.cargo/registry/src/...`)

Cargo's `build.rs` is also preserved for published crates, so dependencies already
influence their own compilation. A dependency's `build.rs` runs during the build and can
emit `cargo:rustc-cfg=`, `cargo:rustc-link-arg=`, etc.

The mechanism for applying dependency tspecs would be:
1. Walk the dependency tree
2. Find each dep's tspec file (if any)
3. Translate to `cargo --config 'profile.release.package.<dep>.<setting>=...'`

Note: `panic` strategy cannot be per-package (must be consistent across dependency graph).

**Package exclude for publishing**

Added `exclude = [".claude/", "notes/"]` to Cargo.toml to avoid publishing session
files and internal notes.

### Status

Design discussion in progress. Next steps:
- Remove `rustc.panic` (duplicate of global panic) [24]
- Define exact fields for `[cargo.profile.*]`
- Decide which remaining `[rustc]` fields to remove vs keep
- Prototype `cargo --config` integration in `apply_spec_to_command()`

## 20260216 - Design: Passing tspec fields via build.rs vs cargo --config

### Context

Follow-up to the profile support design discussion. Investigated whether all tspec fields
associated with a package's cargo parameters for compilation and linking could be passed
via `build.rs` instead of RUSTFLAGS.

### Key findings

**build.rs cannot carry compilation settings**

Cargo deliberately restricts what build script directives can influence. The available
directives and their usefulness for codegen control:

| Directive                    | Effect                          | Useful for codegen? |
|------------------------------|---------------------------------|---------------------|
| `cargo:rustc-cfg=KEY`        | Adds `--cfg KEY`                | No — conditional compilation only |
| `cargo:rustc-env=VAR=VALUE`  | Sets `env!()` at compile time   | No — data, not compiler behavior  |
| `cargo:rustc-flags=FLAGS`    | Restricted to `-l` and `-L`     | No — cargo rejects `-C` flags     |
| `cargo:rustc-link-arg=`      | Passed to linker                | Linker phase only   |
| `cargo:rustc-link-lib=`      | Link a library                  | Linker phase only   |

There is no `cargo:rustc-codegen-option=` or `cargo:rustc-arg=`. This is a deliberate
cargo design choice — codegen settings are controlled centrally by the root manifest,
not by individual packages.

**Dependency Cargo.toml profile settings are ignored**

Cargo only honors `[profile.*]` from the root manifest. Dependencies' profile settings
are silently ignored (workspace members get a warning). The one exception: when a crate
is the root via `cargo install`, its profiles are honored.

Ref: [Profiles - The Cargo Book](https://doc.rust-lang.org/cargo/reference/profiles.html)

**Dependency build.rs scripts ARE always executed**

Unlike profiles, a dependency's `build.rs` always runs — it must, because it can compile
C code, generate source files, probe the system, etc. This is the one place a dependency
gets a voice in its own compilation, but only for linker args, link search paths, cfg
flags, and environment — not codegen options.

**`cargo --config` supports per-package profile overrides**

`cargo --config` can target specific packages:

```bash
# Global — applies to everything
cargo --config 'profile.release.opt-level="s"'

# Per-package — applies ONLY to the named package
cargo --config 'profile.release.package.foo.opt-level=2'
```

This maps to the Cargo.toml `[profile.release.package.<name>]` syntax.

Ref: [Configuration - The Cargo Book](https://doc.rust-lang.org/cargo/reference/config.html)

**Per-package profile overrides have field restrictions**

Not all profile fields are available in per-package overrides. The supported fields:

- `opt-level`, `codegen-units`, `overflow-checks`, `debug`, `debug-assertions`,
  `strip`, `lto`

The following are **excluded** from per-package overrides (profile-global only):

- `panic` — must be consistent across the dependency graph
- `rpath` — whole-build-graph concern (runtime library search paths in the binary)

Ref: [Profiles - Overrides](https://doc.rust-lang.org/cargo/reference/profiles.html#overrides)

**rpath note:** "rpath" = runtime search path, not relative path. It's the `-rpath` linker
flag that embeds library search paths into the ELF/Mach-O binary header so the dynamic
linker finds `.so`/`.dylib` files at runtime without `LD_LIBRARY_PATH`. Most Rust projects
use static linking and never touch it.

### Decision: use `cargo --config profile.*.package.<name>`

For the initial implementation:
1. Use `cargo --config 'profile.*.package.<name>.<field>=<value>'` for profile settings
2. Document the known-supported fields (`opt-level`, `codegen-units`, `overflow-checks`,
   `debug`, `debug-assertions`, `strip`, `lto`) but don't restrict the tspec schema to
   only those — cargo will reject unknown keys with a clear error, and this future-proofs
   against cargo adding new profile fields
3. `panic` and `lto` at the profile-global level (not per-package), `rpath` not needed

### Future thought: build.rs invoking rustc directly

Technically, nothing stops a build.rs from invoking `rustc` directly — the same way the
`cc` crate invokes `gcc`/`clang` to compile C code. A build.rs could:
1. Invoke `rustc` with exact flags the package author wants
2. Output an `.rlib`/`.a` into `OUT_DIR`
3. Emit `cargo:rustc-link-search=` and `cargo:rustc-link-lib=static=`

This would bypass cargo's codegen restrictions entirely. However, it fights cargo hard:
- No incremental compilation, no dep-tracking, no feature resolution
- The "real" crate cargo compiles would be a thin shell linking the pre-compiled artifact
- Crate metadata, proc macros, and cross-crate generics all assume cargo-managed compilation

The restriction on build.rs not passing `-C` flags is a **policy** choice, not a technical
limitation. Cargo is fine with dependencies controlling compilation of other languages
(C/C++ via `cc` crate) but not Rust itself. Filed as "theoretically possible, don't go
there" — stick with `--config` as the practical path.

## 20260215 - Remove rustc.panic (duplicate of global panic)

### Context

Global `panic` (PanicMode) and `rustc.panic` (PanicStrategy) overlap:
- Both emit `-C panic=` into RUSTFLAGS
- If both set, duplicate `-C panic=` flags are emitted (no conflict detection)
- Global `panic` also handles the cargo `-Z panic-immediate-abort` flag for the
  `immediate-abort` case — `rustc.panic` cannot do this
- Real tspec files already use global `panic` and comment out `rustc.panic` with
  the note "prefer top-level panic"
- Tested: setting both vs global-only produces identical builds

`rustc.panic` is strictly a subset of global `panic` with no unique capability.

### Plan

1. `types.rs` — remove `panic` field from `RustcConfig`
2. `cargo_build.rs` — remove the `rustc.panic` RUSTFLAGS block (lines ~300-307)
3. `ts_cmd/edit.rs` — remove `rustc.panic` from field registry and validation
4. Remove any tests referencing `rustc.panic`
5. Verify: `tspec test -p tspec && tspec install --path . && tspec test -p tspec`

### Result

Done. Removed `rustc.panic` (PanicStrategy) — global `panic` (PanicMode) is the sole
panic mechanism. Changes:
- `types.rs` — removed `PanicStrategy` enum and `panic` field from `RustcConfig`
- `cargo_build.rs` — removed `rustc.panic` RUSTFLAGS block, removed `PanicStrategy` import
- `ts_cmd/edit.rs` — removed `rustc.panic` from field registry and validation
- `tests/data/minimal.toml` — moved `panic = "abort"` from `[rustc]` to global
- `tests/tspec_test.rs` — updated to assert `spec.panic` (PanicMode) instead of `spec.rustc.panic`

## 20260216 - Implement [cargo.config_key_value] support

### Context

Follow-up to the `cargo --config` design decisions in [25] and [26]. Adds a
`[cargo.config_key_value]` TOML table to tspec specs. Each entry becomes a
`--config 'KEY=VALUE'` argument to cargo, enabling per-package profile overrides
without bleeding settings through RUSTFLAGS.

### Changes

- `types.rs` — `ConfigValue` enum (Bool, Integer, String) with `#[serde(untagged)]`,
  `config_key_value: BTreeMap<String, ConfigValue>` in `CargoConfig`
- `cargo_build.rs` — inject `--config` args in `apply_spec_to_command()` after unstable flags
- `ts_cmd/edit.rs` — `Table` variant in `FieldKind`, `parse_table_key()` for dotted sub-keys,
  `set_table_value()` and `unset_table_value()` helpers
- `ts_cmd/set.rs` — route Table kind to `set_table_value()`, error on bare table name
- `ts_cmd/unset.rs` — route Table sub-keys to `unset_table_value()`, bare name removes entire table
- `ts_cmd/add.rs`, `ts_cmd/remove.rs` — error text "is not an array field" (was "is a scalar")
- `tests/data/ex-config-kv.ts.toml` — test fixture
- `tests/tspec_test.rs` — 3 integration tests (load, hash stability, hash differs)

### Design decisions

- **BTreeMap** for deterministic ordering (stable hashing and reproducible `--config` arg order)
- **ConfigValue enum** instead of `toml::Value` — avoids `Eq` incompatibility from `Float(f64)`
- **No auto-scoping** — user writes exact cargo config keys
- **No field restrictions** — cargo validates unknown keys with clear errors
- **Existing `[rustc]` fields stay** — migration is a separate follow-up

### Result

Done. 208 unit tests + 8 integration tests pass, clippy clean, fmt clean.
