use anyhow::{Context, Result, bail};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::find_paths::{
    find_crate_dir, find_tspec, find_workspace_root, get_binary_path, get_binary_path_simple,
};
use crate::tspec::load_spec;
use crate::types::{CargoParam, LinkerParam, Profile, RustcParam, Spec};

/// Result of a successful build
pub struct BuildResult {
    pub binary_path: PathBuf,
}

/// Build a crate with a spec, returns the binary path on success
pub fn build_crate(crate_name: &str, tspec: Option<&str>, release: bool) -> Result<BuildResult> {
    let workspace = find_workspace_root()?;
    let crate_dir = find_crate_dir(&workspace, crate_name)?;
    let tspec_path = find_tspec(&crate_dir, tspec)?;

    // Track if we generated a build.rs
    let build_rs_path = crate_dir.join("build.rs");
    let had_build_rs = build_rs_path.exists();

    // Determine binary path based on spec
    let binary_path = if let Some(path) = &tspec_path {
        let spec = load_spec(path)?;
        get_binary_path(&workspace, crate_name, &spec, release)
    } else {
        get_binary_path_simple(&workspace, crate_name, release)
    };

    // Apply spec if present, otherwise plain cargo build
    let status = if let Some(path) = &tspec_path {
        let spec = load_spec(path)?;
        println!("Building {} with spec {}", crate_name, path.display());

        // Generate temporary build.rs for linker flags if needed
        let has_linker_args = spec
            .linker
            .iter()
            .any(|p| matches!(p, LinkerParam::Args(_)));
        if has_linker_args && !had_build_rs {
            generate_build_rs(&build_rs_path, crate_name, &spec)?;
        }

        let mut cmd = build_cargo_command(&spec)?;
        cmd.arg("build");
        cmd.arg("-p").arg(crate_name);
        cmd.current_dir(&workspace);

        apply_spec_to_command(&mut cmd, &spec, &workspace, release)?;
        cmd.status().context("failed to run cargo")?
    } else {
        println!("Building {} (no tspec)", crate_name);
        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        cmd.arg("-p").arg(crate_name);
        cmd.current_dir(&workspace);
        if release {
            cmd.arg("--release");
        }
        cmd.status().context("failed to run cargo")?
    };

    // Clean up generated build.rs (only if we created it)
    if !had_build_rs && build_rs_path.exists() {
        let _ = fs::remove_file(&build_rs_path);
    }

    if !status.success() {
        bail!("cargo build failed");
    }

    println!("  {}", binary_path.display());
    Ok(BuildResult { binary_path })
}

/// Generate a temporary build.rs with scoped linker flags from tspec.toml
pub fn generate_build_rs(path: &Path, crate_name: &str, spec: &Spec) -> Result<()> {
    let mut lines = vec![
        "// Generated by xt - do not edit".to_string(),
        "fn main() {".to_string(),
    ];

    for param in &spec.linker {
        if let LinkerParam::Args(args) = param {
            for arg in args {
                lines.push(format!(
                    "    println!(\"cargo:rustc-link-arg-bin={}={}\");",
                    crate_name, arg
                ));
            }
        }
    }

    lines.push("}".to_string());
    fs::write(path, lines.join("\n")).context("failed to write build.rs")?;
    Ok(())
}

/// Check if spec requires nightly toolchain
fn requires_nightly(spec: &Spec) -> bool {
    // BuildStd requires nightly
    let has_build_std = spec
        .rustc
        .iter()
        .any(|p| matches!(p, RustcParam::BuildStd(_)));

    // Unstable cargo flags require nightly
    let has_unstable = spec
        .cargo
        .iter()
        .any(|p| matches!(p, CargoParam::Unstable(_)));

    has_build_std || has_unstable
}

/// Build the base cargo command (with toolchain if needed)
fn build_cargo_command(spec: &Spec) -> Result<Command> {
    let mut cmd = Command::new("cargo");

    if requires_nightly(spec) {
        cmd.arg("+nightly");
    }

    Ok(cmd)
}

/// Apply spec parameters to a cargo command
pub fn apply_spec_to_command(
    cmd: &mut Command,
    spec: &Spec,
    workspace: &Path,
    release: bool,
) -> Result<()> {
    // Handle cargo params
    let mut has_profile = false;
    for param in &spec.cargo {
        match param {
            CargoParam::Profile(p) => {
                has_profile = true;
                match p {
                    Profile::Release => {
                        cmd.arg("--release");
                    }
                    Profile::Debug => {
                        // Debug is default, no flag needed
                    }
                }
            }
            CargoParam::TargetTriple(triple) => {
                cmd.arg("--target").arg(triple);
            }
            CargoParam::TargetJson(path) => {
                cmd.arg("--target").arg(path);
            }
            CargoParam::Unstable(flag) => {
                cmd.arg("-Z").arg(flag);
            }
        }
    }

    // If no profile in spec but release flag passed, use release
    if !has_profile && release {
        cmd.arg("--release");
    }

    // Collect rustc flags
    let mut rustc_flags: Vec<String> = Vec::new();

    // Handle rustc params
    for param in &spec.rustc {
        match param {
            RustcParam::OptLevel(level) => {
                let lvl = match level {
                    crate::types::OptLevel::O0 => "0",
                    crate::types::OptLevel::O1 => "1",
                    crate::types::OptLevel::O2 => "2",
                    crate::types::OptLevel::O3 => "3",
                    crate::types::OptLevel::Os => "s",
                    crate::types::OptLevel::Oz => "z",
                };
                rustc_flags.push(format!("-C opt-level={}", lvl));
            }
            RustcParam::Panic(strategy) => {
                let s = match strategy {
                    crate::types::PanicStrategy::Abort => "abort",
                    crate::types::PanicStrategy::Unwind => "unwind",
                    crate::types::PanicStrategy::ImmediateAbort => "immediate-abort",
                };
                rustc_flags.push(format!("-C panic={}", s));
            }
            RustcParam::Lto(enabled) => {
                if *enabled {
                    rustc_flags.push("-C lto=true".to_string());
                }
            }
            RustcParam::CodegenUnits(n) => {
                rustc_flags.push(format!("-C codegen-units={}", n));
            }
            RustcParam::BuildStd(crates) => {
                // -Z build-std is a cargo flag, not rustc
                let crates_str = crates.join(",");
                cmd.arg("-Z").arg(format!("build-std={}", crates_str));
            }
            RustcParam::Flag(flag) => {
                rustc_flags.push(flag.clone());
            }
        }
    }

    // Handle version script (generates file and adds linker arg)
    for param in &spec.linker {
        if let LinkerParam::VersionScript(vs) = param {
            let target_dir = workspace.join("target");
            let _ = fs::create_dir_all(&target_dir);
            let version_script_path = target_dir.join("xt-version.script");

            // Generate version script: { global: sym1; sym2; local: *; };
            let globals = vs.global.join("; ");
            let content = format!("{{ global: {}; local: {}; }};", globals, vs.local);

            let mut f = fs::File::create(&version_script_path)
                .context("failed to create version script")?;
            writeln!(f, "{}", content)?;

            rustc_flags.push(format!(
                "-C link-arg=-Wl,--version-script={}",
                version_script_path.display()
            ));
        }
    }

    // Apply rustc flags (linker args from Args handled by generated build.rs)
    if !rustc_flags.is_empty() {
        cmd.env("RUSTFLAGS", rustc_flags.join(" "));
    }

    Ok(())
}
