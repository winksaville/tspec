use anyhow::{Context, Result, bail};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::find_paths::{
    find_package_dir, find_project_root, find_tspec, get_binary_path, get_binary_path_simple,
    get_package_name,
};
use crate::tspec::{expand_target_dir, load_spec, spec_name_from_path};
use crate::types::{Spec, flatten_config};

const TSPEC_BUILD_RS_MARKER: &str = "// Generated by tspec - do not edit";

/// Built-in cargo profiles that don't require a `[profile.<name>]` definition.
const BUILTIN_PROFILES: &[&str] = &["dev", "debug", "release", "test", "bench"];

/// Validate that a custom profile is defined in the workspace Cargo.toml.
/// Built-in profiles (dev, release, test, bench) are always valid.
/// Custom profiles must have a `[profile.<name>]` section with `inherits`.
pub fn validate_profile(profile: &str, workspace: &Path) -> Result<()> {
    if BUILTIN_PROFILES.contains(&profile) {
        return Ok(());
    }
    let cargo_toml_path = workspace.join("Cargo.toml");
    let content = fs::read_to_string(&cargo_toml_path)
        .with_context(|| format!("failed to read {}", cargo_toml_path.display()))?;
    let doc: toml::Value =
        toml::from_str(&content).context("failed to parse workspace Cargo.toml")?;
    if let Some(profiles) = doc.get("profile").and_then(|p| p.as_table())
        && profiles.contains_key(profile)
    {
        return Ok(());
    }
    bail!(
        "profile `{}` is not defined in {}. Custom profiles must be defined with \
         `[profile.{}]` and an `inherits` field (e.g., `inherits = \"release\"`).",
        profile,
        cargo_toml_path.display(),
        profile,
    )
}
/// Check for spec settings that are likely misconfigurations.
/// Returns a list of warning messages (printed at top and bottom of output).
pub fn check_spec_misconfigurations(pkg_name: &str, spec: &Spec, pkg_dir: &Path) -> Vec<String> {
    let mut warnings = Vec::new();
    let has_linker_args = !spec.linker.args.is_empty();
    let has_bin_target = pkg_dir.join("src/main.rs").exists();

    // -static with non-musl target (glibc + -static segfaults)
    if has_linker_args {
        let has_static = spec.linker.args.iter().any(|a| a == "-static");
        let is_musl = spec
            .cargo
            .target_triple
            .as_ref()
            .is_some_and(|t| t.contains("musl"));
        if has_static && !is_musl {
            warnings.push(format!(
                "Warning: -static linker arg without musl target for {}. \
                 glibc + -static often segfaults; consider using a musl target triple.",
                pkg_name
            ));
        }
    }

    // linker.args on lib-only package
    if has_linker_args && !has_bin_target {
        warnings.push(format!(
            "Warning: linker.args ignored for {} (no binary target)",
            pkg_name
        ));
    }

    warnings
}

/// Print collected warnings again so they're visible after cargo output.
pub fn reprint_warnings(warnings: &[String]) {
    for w in warnings {
        println!("{}", w);
    }
}

pub fn warn_stale_build_rs(had_stale: bool) {
    if had_stale {
        println!("Warning: a stale build.rs was deleted, likely from a previous interrupted build");
    }
}

/// Check if a build.rs file was generated by tspec.
/// Matches either the marker comment or a file that only contains
/// `cargo:rustc-link-arg-bin=` println lines (marker-less variant).
fn is_tspec_generated_build_rs(content: &str) -> bool {
    if content.starts_with(TSPEC_BUILD_RS_MARKER) {
        return true;
    }
    // Fallback: file only contains fn main, cargo:rustc-link-arg-bin printlns, and braces
    let dominated_by_link_args = content
        .lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .all(|l| {
            l == "fn main() {"
                || l == "}"
                || l.starts_with(TSPEC_BUILD_RS_MARKER)
                || l.contains("cargo:rustc-link-arg-bin=")
        });
    dominated_by_link_args && content.contains("cargo:rustc-link-arg-bin=")
}

/// Remove a stale tspec-generated build.rs left behind by an interrupted build.
/// Returns true if a stale file was removed. Caller should print a warning after the build.
pub fn remove_stale_tspec_build_rs(pkg_dir: &Path) -> bool {
    let build_rs = pkg_dir.join("build.rs");
    if let Ok(content) = fs::read_to_string(&build_rs)
        && is_tspec_generated_build_rs(&content)
    {
        let _ = fs::remove_file(&build_rs);
        return true;
    }
    false
}

/// Result of a successful build
pub struct BuildResult {
    pub binary_path: PathBuf,
    /// The effective target directory base (e.g., "target/foo" if target_dir was set)
    pub target_base: PathBuf,
}

/// Build a package with a spec, returns the binary path on success.
/// `cli_profile` is the profile from the CLI (e.g., "release", "release-small").
/// `None` means debug (default). `Some("release")` is equivalent to `--release`.
pub fn build_package(
    pkg_name: &str,
    tspec: Option<&str>,
    cli_profile: Option<&str>,
) -> Result<BuildResult> {
    let workspace = find_project_root()?;
    let pkg_dir = find_package_dir(&workspace, pkg_name)?;
    let tspec_path = find_tspec(&pkg_dir, tspec)?;

    // Resolve actual package name from Cargo.toml (needed when pkg_name is a path)
    let pkg_name = get_package_name(&pkg_dir)?;

    // Clean up any stale tspec-generated build.rs from interrupted builds
    let had_stale_build_rs = remove_stale_tspec_build_rs(&pkg_dir);

    // Track if we generated a build.rs
    let build_rs_path = pkg_dir.join("build.rs");
    let had_build_rs = build_rs_path.exists();

    // Load spec once (if present) and compute target_dir
    let (spec, expanded_td) = if let Some(path) = &tspec_path {
        let s = load_spec(path)?;
        let name = spec_name_from_path(path);
        let td = expand_target_dir(&s, &name)?;
        (Some(s), td)
    } else {
        (None, None)
    };

    // Compute paths
    let target_base = match &expanded_td {
        Some(td) => workspace.join("target").join(td),
        None => workspace.join("target"),
    };
    let binary_path = if let Some(spec) = &spec {
        get_binary_path(
            &workspace,
            &pkg_name,
            spec,
            cli_profile,
            expanded_td.as_deref(),
        )
    } else {
        get_binary_path_simple(&workspace, &pkg_name, cli_profile)
    };

    // Validate the effective profile exists before invoking cargo
    let effective_profile = spec
        .as_ref()
        .and_then(|s| s.cargo.profile.as_deref())
        .or(cli_profile);
    if let Some(profile) = effective_profile {
        validate_profile(profile, &workspace)?;
    }

    // Check for misconfigurations before running cargo
    let spec_warnings = if let Some(spec) = &spec {
        check_spec_misconfigurations(&pkg_name, spec, &pkg_dir)
    } else {
        Vec::new()
    };

    // Apply spec if present, otherwise plain cargo build
    let status = if let Some(spec) = &spec {
        let path = tspec_path.as_ref().unwrap();
        println!("Building {} with spec {}", pkg_name, path.display());

        // Generate temporary build.rs for linker flags if needed
        let has_linker_args = !spec.linker.args.is_empty();
        let has_bin_target = pkg_dir.join("src/main.rs").exists();
        if has_linker_args && has_bin_target && !had_build_rs {
            generate_build_rs(&build_rs_path, &pkg_name, spec)?;
        }

        let mut cmd = build_cargo_command(spec)?;
        cmd.arg("build");
        cmd.arg("-p").arg(&pkg_name);
        cmd.current_dir(&workspace);

        // Set spec path for tspec-build library to read in build.rs
        cmd.env("TSPEC_SPEC_FILE", path.as_os_str());

        apply_spec_to_command(
            &mut cmd,
            spec,
            &workspace,
            cli_profile,
            expanded_td.as_deref(),
        )?;
        cmd.status().context("failed to run cargo")?
    } else {
        println!("Building {} (no tspec)", pkg_name);
        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        cmd.arg("-p").arg(&pkg_name);
        cmd.current_dir(&workspace);
        if let Some(p) = cli_profile {
            match p {
                "debug" | "dev" => {}
                _ => {
                    cmd.arg("--profile").arg(p);
                }
            }
        }
        cmd.status().context("failed to run cargo")?
    };

    // Clean up generated build.rs (only if we created it)
    if !had_build_rs && build_rs_path.exists() {
        let _ = fs::remove_file(&build_rs_path);
    }

    if !status.success() {
        match &tspec_path {
            Some(path) => {
                let display_path = path.strip_prefix(&workspace).unwrap_or(path).display();
                bail!(
                    "cargo build failed for `{}` with spec {}",
                    pkg_name,
                    display_path
                )
            }
            None => bail!("cargo build failed for `{}`", pkg_name),
        }
    }

    println!("  {}", binary_path.display());
    warn_stale_build_rs(had_stale_build_rs);
    reprint_warnings(&spec_warnings);
    Ok(BuildResult {
        binary_path,
        target_base,
    })
}

/// Plain `cargo build --release` with no spec lookup.
/// Used by compare to produce a baseline build.
pub fn plain_cargo_build_release(pkg_name: &str) -> Result<BuildResult> {
    build_package(pkg_name, None, Some("release"))
}

/// Generate a temporary build.rs with scoped linker flags from tspec.toml
pub fn generate_build_rs(path: &Path, crate_name: &str, spec: &Spec) -> Result<()> {
    let mut lines = vec![TSPEC_BUILD_RS_MARKER.to_string(), "fn main() {".to_string()];

    for arg in &spec.linker.args {
        lines.push(format!(
            "    println!(\"cargo:rustc-link-arg-bin={}={}\");",
            crate_name, arg
        ));
    }

    lines.push("}".to_string());
    fs::write(path, lines.join("\n")).context("failed to write build.rs")?;
    Ok(())
}

/// Check if spec requires nightly toolchain
fn requires_nightly(spec: &Spec) -> bool {
    // High-level panic mode may require nightly
    let panic_needs_nightly = spec.panic.map(|p| p.requires_nightly()).unwrap_or(false);

    // BuildStd requires nightly
    let has_build_std = !spec.cargo.build_std.is_empty();

    // Unstable cargo flags require nightly
    let has_unstable = !spec.cargo.unstable.is_empty();

    panic_needs_nightly || has_build_std || has_unstable
}

/// Build the base cargo command (with toolchain if needed)
fn build_cargo_command(spec: &Spec) -> Result<Command> {
    let mut cmd = Command::new("cargo");

    if requires_nightly(spec) {
        cmd.arg("+nightly");
    }

    Ok(cmd)
}

/// Apply spec parameters to a cargo command.
/// `cli_profile` is the CLI-specified profile (None = debug default).
pub fn apply_spec_to_command(
    cmd: &mut Command,
    spec: &Spec,
    workspace: &Path,
    cli_profile: Option<&str>,
    expanded_target_dir: Option<&str>,
) -> Result<()> {
    // Set custom target directory if specified
    if let Some(td) = expanded_target_dir {
        cmd.arg("--target-dir")
            .arg(workspace.join("target").join(td));
    }

    // Handle high-level panic mode (cargo -Z flag)
    if let Some(panic_mode) = spec.panic
        && let Some(z_flag) = panic_mode.cargo_z_flag()
    {
        cmd.arg("-Z").arg(z_flag);
    }

    // Handle cargo config
    let has_profile = spec.cargo.profile.is_some();
    if let Some(ref profile) = spec.cargo.profile {
        match profile.as_str() {
            "debug" | "dev" => {
                // Debug/dev is default, no flag needed
            }
            _ => {
                cmd.arg("--profile").arg(profile);
            }
        }
    }

    if let Some(ref triple) = spec.cargo.target_triple {
        cmd.arg("--target").arg(triple);
    }

    if let Some(ref path) = spec.cargo.target_json {
        cmd.arg("-Z").arg("json-target-spec");
        cmd.arg("--target").arg(path);
    }

    for flag in &spec.cargo.unstable {
        cmd.arg("-Z").arg(flag);
    }

    // Inject --config key=value pairs (flattened from potentially nested config)
    for (key, value) in flatten_config(&spec.cargo.config) {
        cmd.arg("--config").arg(format!("{}={}", key, value));
    }

    // If no profile in spec, fall back to CLI profile
    if !has_profile && let Some(p) = cli_profile {
        match p {
            "debug" | "dev" => {} // default, no flag needed
            _ => {
                cmd.arg("--profile").arg(p);
            }
        }
    }

    // Collect rustc flags
    let mut rustc_flags: Vec<String> = Vec::new();

    // Handle high-level panic mode (rustc -C flag)
    if let Some(panic_mode) = spec.panic
        && let Some(panic_value) = panic_mode.rustc_panic_value()
    {
        rustc_flags.push(format!("-C panic={}", panic_value));
    }

    // Handle high-level strip mode
    if let Some(strip_mode) = spec.strip
        && let Some(strip_value) = strip_mode.rustc_strip_value()
    {
        rustc_flags.push(format!("-C strip={}", strip_value));
    }

    if !spec.cargo.build_std.is_empty() {
        // -Z build-std is a cargo flag, not rustc
        let crates_str = spec.cargo.build_std.join(",");
        cmd.arg("-Z").arg(format!("build-std={}", crates_str));
    }

    for flag in &spec.rustflags {
        rustc_flags.push(flag.clone());
    }

    // Handle version script (generates file and adds linker arg)
    if let Some(vs) = &spec.linker.version_script {
        let vs_dir = match expanded_target_dir {
            Some(td) => workspace.join("target").join(td),
            None => workspace.join("target"),
        };
        let _ = fs::create_dir_all(&vs_dir);
        let version_script_path = vs_dir.join("tspec-version.script");

        // Generate version script: { global: sym1; sym2; local: *; };
        let globals = vs.global.join("; ");
        let content = format!("{{ global: {}; local: {}; }};", globals, vs.local);

        let mut f =
            fs::File::create(&version_script_path).context("failed to create version script")?;
        writeln!(f, "{}", content)?;

        rustc_flags.push(format!(
            "-C link-arg=-Wl,--version-script={}",
            version_script_path.display()
        ));
    }

    // Apply rustc flags (linker args from Args handled by generated build.rs)
    if !rustc_flags.is_empty() {
        cmd.env("RUSTFLAGS", rustc_flags.join(" "));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn remove_stale_tspec_build_rs_removes_marker_file() {
        let tmp = TempDir::new().unwrap();
        let build_rs = tmp.path().join("build.rs");
        fs::write(
            &build_rs,
            "// Generated by tspec - do not edit\nfn main() {\n}\n",
        )
        .unwrap();

        assert!(remove_stale_tspec_build_rs(tmp.path()));
        assert!(!build_rs.exists());
    }

    #[test]
    fn remove_stale_tspec_build_rs_preserves_user_file() {
        let tmp = TempDir::new().unwrap();
        let build_rs = tmp.path().join("build.rs");
        fs::write(
            &build_rs,
            "fn main() {\n    println!(\"cargo:rerun-if-changed=src\");\n}\n",
        )
        .unwrap();

        assert!(!remove_stale_tspec_build_rs(tmp.path()));
        assert!(build_rs.exists());
    }

    #[test]
    fn remove_stale_tspec_build_rs_removes_markerless_link_arg_file() {
        let tmp = TempDir::new().unwrap();
        let build_rs = tmp.path().join("build.rs");
        fs::write(
            &build_rs,
            "fn main() {\n    println!(\"cargo:rustc-link-arg-bin=tspec=-static\");\n}\n",
        )
        .unwrap();

        assert!(remove_stale_tspec_build_rs(tmp.path()));
        assert!(!build_rs.exists());
    }

    #[test]
    fn remove_stale_tspec_build_rs_no_file() {
        let tmp = TempDir::new().unwrap();
        assert!(!remove_stale_tspec_build_rs(tmp.path()));
    }

    // is_tspec_generated_build_rs unit tests

    #[test]
    fn is_tspec_generated_with_marker() {
        let content = "// Generated by tspec - do not edit\nfn main() {\n}\n";
        assert!(is_tspec_generated_build_rs(content));
    }

    #[test]
    fn is_tspec_generated_without_marker() {
        let content = concat!(
            "fn main() {\n",
            "    println!(\"cargo:rustc-link-arg-bin=tspec=-static\");\n",
            "    println!(\"cargo:rustc-link-arg-bin=tspec=-nostdlib\");\n",
            "}\n",
        );
        assert!(is_tspec_generated_build_rs(content));
    }

    #[test]
    fn is_tspec_generated_rejects_user_build_rs() {
        let content = "fn main() {\n    println!(\"cargo:rerun-if-changed=src\");\n}\n";
        assert!(!is_tspec_generated_build_rs(content));
    }

    #[test]
    fn target_json_adds_json_target_spec_flag() {
        let mut spec = Spec::default();
        spec.cargo.target_json = Some(PathBuf::from("x86_64-custom.json"));

        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        let workspace = PathBuf::from("/tmp/fake");
        apply_spec_to_command(&mut cmd, &spec, &workspace, None, None).unwrap();

        let args: Vec<String> = cmd.get_args().map(|a| a.to_string_lossy().into()).collect();
        // Should have: -Z json-target-spec --target x86_64-custom.json
        let z_pos = args.iter().position(|a| a == "-Z").unwrap();
        assert_eq!(args[z_pos + 1], "json-target-spec");
        let target_pos = args.iter().position(|a| a == "--target").unwrap();
        assert_eq!(args[target_pos + 1], "x86_64-custom.json");
        assert!(
            z_pos < target_pos,
            "-Z json-target-spec should come before --target"
        );
    }

    #[test]
    fn target_triple_does_not_add_json_target_spec_flag() {
        let mut spec = Spec::default();
        spec.cargo.target_triple = Some("x86_64-unknown-linux-gnu".to_string());

        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        let workspace = PathBuf::from("/tmp/fake");
        apply_spec_to_command(&mut cmd, &spec, &workspace, None, None).unwrap();

        let args: Vec<String> = cmd.get_args().map(|a| a.to_string_lossy().into()).collect();
        assert!(!args.contains(&"json-target-spec".to_string()));
        let target_pos = args.iter().position(|a| a == "--target").unwrap();
        assert_eq!(args[target_pos + 1], "x86_64-unknown-linux-gnu");
    }

    #[test]
    fn config_emits_config_args() {
        use crate::types::ConfigValue;
        use std::collections::BTreeMap;

        let mut spec = Spec::default();
        spec.cargo.config = BTreeMap::from([
            (
                "profile.release.opt-level".to_string(),
                ConfigValue::String("s".to_string()),
            ),
            ("profile.release.lto".to_string(), ConfigValue::Bool(true)),
            (
                "profile.release.codegen-units".to_string(),
                ConfigValue::Integer(1),
            ),
        ]);

        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        let workspace = PathBuf::from("/tmp/fake");
        apply_spec_to_command(&mut cmd, &spec, &workspace, None, None).unwrap();

        let args: Vec<String> = cmd.get_args().map(|a| a.to_string_lossy().into()).collect();

        // BTreeMap is sorted, so codegen-units < lto < opt-level
        let config_positions: Vec<usize> = args
            .iter()
            .enumerate()
            .filter(|(_, a)| *a == "--config")
            .map(|(i, _)| i)
            .collect();
        assert_eq!(config_positions.len(), 3);

        // Check each --config arg
        assert_eq!(
            args[config_positions[0] + 1],
            "profile.release.codegen-units=1"
        );
        assert_eq!(args[config_positions[1] + 1], "profile.release.lto=true");
        assert_eq!(
            args[config_positions[2] + 1],
            "profile.release.opt-level=\"s\""
        );
    }

    #[test]
    fn config_nested_table_emits_config_args() {
        use crate::types::ConfigValue;
        use std::collections::BTreeMap;

        let mut spec = Spec::default();
        // Nested form: { profile: { release: { opt-level: "z", codegen-units: 1 } } }
        spec.cargo.config = BTreeMap::from([(
            "profile".to_string(),
            ConfigValue::Table(BTreeMap::from([(
                "release".to_string(),
                ConfigValue::Table(BTreeMap::from([
                    ("codegen-units".to_string(), ConfigValue::Integer(1)),
                    (
                        "opt-level".to_string(),
                        ConfigValue::String("z".to_string()),
                    ),
                ])),
            )])),
        )]);

        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        let workspace = PathBuf::from("/tmp/fake");
        apply_spec_to_command(&mut cmd, &spec, &workspace, None, None).unwrap();

        let args: Vec<String> = cmd.get_args().map(|a| a.to_string_lossy().into()).collect();

        let config_positions: Vec<usize> = args
            .iter()
            .enumerate()
            .filter(|(_, a)| *a == "--config")
            .map(|(i, _)| i)
            .collect();
        assert_eq!(config_positions.len(), 2);

        assert_eq!(
            args[config_positions[0] + 1],
            "profile.release.codegen-units=1"
        );
        assert_eq!(
            args[config_positions[1] + 1],
            "profile.release.opt-level=\"z\""
        );
    }

    #[test]
    fn config_empty_emits_nothing() {
        let spec = Spec::default();

        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        let workspace = PathBuf::from("/tmp/fake");
        apply_spec_to_command(&mut cmd, &spec, &workspace, None, None).unwrap();

        let args: Vec<String> = cmd.get_args().map(|a| a.to_string_lossy().into()).collect();
        assert!(!args.contains(&"--config".to_string()));
    }

    #[test]
    fn validate_profile_accepts_builtins() {
        let tmp = TempDir::new().unwrap();
        fs::write(
            tmp.path().join("Cargo.toml"),
            "[package]\nname = \"test\"\nversion = \"0.1.0\"\n",
        )
        .unwrap();
        for profile in &["dev", "debug", "release", "test", "bench"] {
            validate_profile(profile, tmp.path()).unwrap();
        }
    }

    #[test]
    fn validate_profile_rejects_undefined_custom() {
        let tmp = TempDir::new().unwrap();
        fs::write(
            tmp.path().join("Cargo.toml"),
            "[package]\nname = \"test\"\nversion = \"0.1.0\"\n",
        )
        .unwrap();
        let err = validate_profile("other", tmp.path()).unwrap_err();
        assert!(
            err.to_string().contains("is not defined"),
            "expected 'is not defined' in: {}",
            err
        );
    }

    #[test]
    fn validate_profile_accepts_defined_custom() {
        let tmp = TempDir::new().unwrap();
        fs::write(
            tmp.path().join("Cargo.toml"),
            concat!(
                "[package]\nname = \"test\"\nversion = \"0.1.0\"\n",
                "[profile.release-small]\ninherits = \"release\"\nopt-level = \"z\"\n",
            ),
        )
        .unwrap();
        validate_profile("release-small", tmp.path()).unwrap();
    }

    #[test]
    fn is_tspec_generated_rejects_mixed_content() {
        let content = concat!(
            "fn main() {\n",
            "    println!(\"cargo:rerun-if-changed=build.rs\");\n",
            "    println!(\"cargo:rustc-link-arg-bin=myapp=-lfoo\");\n",
            "}\n",
        );
        assert!(!is_tspec_generated_build_rs(content));
    }
}
