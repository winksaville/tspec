use anyhow::{Context, Result, bail};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::find_paths::{
    find_package_dir, find_tspec, find_project_root, get_binary_path, get_binary_path_simple,
    get_crate_name,
};
use crate::tspec::load_spec;
use crate::types::{OptLevel, PanicStrategy, Profile, Spec};

/// Result of a successful build
pub struct BuildResult {
    pub binary_path: PathBuf,
}

/// Build a crate with a spec, returns the binary path on success
pub fn build_crate(crate_name: &str, tspec: Option<&str>, release: bool) -> Result<BuildResult> {
    let workspace = find_project_root()?;
    let crate_dir = find_package_dir(&workspace, crate_name)?;
    let tspec_path = find_tspec(&crate_dir, tspec)?;

    // Get actual package name from Cargo.toml (needed when crate_name is a path)
    let pkg_name = get_crate_name(&crate_dir)?;

    // Track if we generated a build.rs
    let build_rs_path = crate_dir.join("build.rs");
    let had_build_rs = build_rs_path.exists();

    // Determine binary path based on spec
    let binary_path = if let Some(path) = &tspec_path {
        let spec = load_spec(path)?;
        get_binary_path(&workspace, &pkg_name, &spec, release)
    } else {
        get_binary_path_simple(&workspace, &pkg_name, release)
    };

    // Apply spec if present, otherwise plain cargo build
    let status = if let Some(path) = &tspec_path {
        let spec = load_spec(path)?;
        println!("Building {} with spec {}", pkg_name, path.display());

        // Generate temporary build.rs for linker flags if needed
        let has_linker_args = !spec.linker.args.is_empty();
        if has_linker_args && !had_build_rs {
            generate_build_rs(&build_rs_path, &pkg_name, &spec)?;
        }

        let mut cmd = build_cargo_command(&spec)?;
        cmd.arg("build");
        cmd.arg("-p").arg(&pkg_name);
        cmd.current_dir(&workspace);

        apply_spec_to_command(&mut cmd, &spec, &workspace, release)?;
        cmd.status().context("failed to run cargo")?
    } else {
        println!("Building {} (no tspec)", pkg_name);
        let mut cmd = Command::new("cargo");
        cmd.arg("build");
        cmd.arg("-p").arg(&pkg_name);
        cmd.current_dir(&workspace);
        if release {
            cmd.arg("--release");
        }
        cmd.status().context("failed to run cargo")?
    };

    // Clean up generated build.rs (only if we created it)
    if !had_build_rs && build_rs_path.exists() {
        let _ = fs::remove_file(&build_rs_path);
    }

    if !status.success() {
        bail!("cargo build failed");
    }

    println!("  {}", binary_path.display());
    Ok(BuildResult { binary_path })
}

/// Generate a temporary build.rs with scoped linker flags from tspec.toml
pub fn generate_build_rs(path: &Path, crate_name: &str, spec: &Spec) -> Result<()> {
    let mut lines = vec![
        "// Generated by tspec - do not edit".to_string(),
        "fn main() {".to_string(),
    ];

    for arg in &spec.linker.args {
        lines.push(format!(
            "    println!(\"cargo:rustc-link-arg-bin={}={}\");",
            crate_name, arg
        ));
    }

    lines.push("}".to_string());
    fs::write(path, lines.join("\n")).context("failed to write build.rs")?;
    Ok(())
}

/// Check if spec requires nightly toolchain
fn requires_nightly(spec: &Spec) -> bool {
    // High-level panic mode may require nightly
    let panic_needs_nightly = spec.panic.map(|p| p.requires_nightly()).unwrap_or(false);

    // BuildStd requires nightly
    let has_build_std = !spec.rustc.build_std.is_empty();

    // Unstable cargo flags require nightly
    let has_unstable = !spec.cargo.unstable.is_empty();

    panic_needs_nightly || has_build_std || has_unstable
}

/// Build the base cargo command (with toolchain if needed)
fn build_cargo_command(spec: &Spec) -> Result<Command> {
    let mut cmd = Command::new("cargo");

    if requires_nightly(spec) {
        cmd.arg("+nightly");
    }

    Ok(cmd)
}

/// Apply spec parameters to a cargo command
pub fn apply_spec_to_command(
    cmd: &mut Command,
    spec: &Spec,
    workspace: &Path,
    release: bool,
) -> Result<()> {
    // Handle high-level panic mode (cargo -Z flag)
    if let Some(panic_mode) = spec.panic
        && let Some(z_flag) = panic_mode.cargo_z_flag()
    {
        cmd.arg("-Z").arg(z_flag);
    }

    // Handle cargo config
    let has_profile = spec.cargo.profile.is_some();
    if let Some(ref profile) = spec.cargo.profile {
        match profile {
            Profile::Release => {
                cmd.arg("--release");
            }
            Profile::Debug => {
                // Debug is default, no flag needed
            }
        }
    }

    if let Some(ref triple) = spec.cargo.target_triple {
        cmd.arg("--target").arg(triple);
    }

    if let Some(ref path) = spec.cargo.target_json {
        cmd.arg("--target").arg(path);
    }

    for flag in &spec.cargo.unstable {
        cmd.arg("-Z").arg(flag);
    }

    // If no profile in spec but release flag passed, use release
    if !has_profile && release {
        cmd.arg("--release");
    }

    // Collect rustc flags
    let mut rustc_flags: Vec<String> = Vec::new();

    // Handle high-level panic mode (rustc -C flag)
    if let Some(panic_mode) = spec.panic
        && let Some(panic_value) = panic_mode.rustc_panic_value()
    {
        rustc_flags.push(format!("-C panic={}", panic_value));
    }

    // Handle rustc config
    let rustc = &spec.rustc;

    if let Some(level) = &rustc.opt_level {
        let lvl = match level {
            OptLevel::O0 => "0",
            OptLevel::O1 => "1",
            OptLevel::O2 => "2",
            OptLevel::O3 => "3",
            OptLevel::Os => "s",
            OptLevel::Oz => "z",
        };
        rustc_flags.push(format!("-C opt-level={}", lvl));
    }

    if let Some(strategy) = &rustc.panic {
        let s = match strategy {
            PanicStrategy::Abort => "abort",
            PanicStrategy::Unwind => "unwind",
            PanicStrategy::ImmediateAbort => "immediate-abort",
        };
        rustc_flags.push(format!("-C panic={}", s));
    }

    if let Some(true) = rustc.lto {
        rustc_flags.push("-C lto=true".to_string());
    }

    if let Some(n) = rustc.codegen_units {
        rustc_flags.push(format!("-C codegen-units={}", n));
    }

    // Handle high-level strip mode
    if let Some(strip_mode) = spec.strip
        && let Some(strip_value) = strip_mode.rustc_strip_value()
    {
        rustc_flags.push(format!("-C strip={}", strip_value));
    }

    if !rustc.build_std.is_empty() {
        // -Z build-std is a cargo flag, not rustc
        let crates_str = rustc.build_std.join(",");
        cmd.arg("-Z").arg(format!("build-std={}", crates_str));
    }

    for flag in &rustc.flags {
        rustc_flags.push(flag.clone());
    }

    // Handle version script (generates file and adds linker arg)
    if let Some(vs) = &spec.linker.version_script {
        let target_dir = workspace.join("target");
        let _ = fs::create_dir_all(&target_dir);
        let version_script_path = target_dir.join("tspec-version.script");

        // Generate version script: { global: sym1; sym2; local: *; };
        let globals = vs.global.join("; ");
        let content = format!("{{ global: {}; local: {}; }};", globals, vs.local);

        let mut f =
            fs::File::create(&version_script_path).context("failed to create version script")?;
        writeln!(f, "{}", content)?;

        rustc_flags.push(format!(
            "-C link-arg=-Wl,--version-script={}",
            version_script_path.display()
        ));
    }

    // Apply rustc flags (linker args from Args handled by generated build.rs)
    if !rustc_flags.is_empty() {
        cmd.env("RUSTFLAGS", rustc_flags.join(" "));
    }

    Ok(())
}
